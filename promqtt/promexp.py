'''Prometheus exporter'''

from datetime import datetime
import logging
from threading import Lock


logger = logging.getLogger(__name__)


class PrometheusExporterException(Exception):
    '''Base class for all exceptions generated by the PrometheusExporter.'''


class UnknownMeasurementException(PrometheusExporterException):
    '''Raised when you try to set a value for a measurement not registered
    yet.'''


def _get_time():
    '''Return the current time as a datetime object.

    Wrapped in a function, so it can be stubbed for testing.'''

    return datetime.now()


def _get_label_string(labels):
    '''Convert a dictionary of labels to a unique label string'''

    labelstr = ','.join(
        [f'{k}="{labels[k]}"' for k in sorted(labels.keys())]
    )

    return labelstr


class Metric():
    '''Represents a Prometheus metric, i.e. a metric name with its helptext and type
    information.'''

    def __init__(self, name, datatype, helpstr, timeout=None, with_update_counter=False): # pylint: disable=too-many-arguments
        self._name = name
        self._datatype = datatype
        self._helpstr = helpstr
        self._timeout = timeout
        self._data = {}
        self._with_update_counter = with_update_counter


    @property
    def name(self):
        '''Return the metric name'''
        return self._name


    @property
    def datatype(self):
        '''Return the metric datatype (gauge, counter, ...)'''
        return self._datatype

    @property
    def helptext(self):
        '''Return the metric help text'''

        return self._helpstr

    @property
    def timeout(self):
        '''Return the timeout in seconds for this metric. Metric instances are removed
        from the metric after the timeout is expired.'''

        return self._timeout


    @property
    def with_update_counter(self):
        '''Returns true if this metric has an associated update counter metric.'''

        return self._with_update_counter


    def set(self, labels, value):
        '''Set a value for a metric instance'''

        labelstr = _get_label_string(labels)

        # If we do not know this instance yet
        if labelstr not in self._data:

            # we do not add new metrics without assigned value
            if value is None:
                return

            # we don't know this instance yet, so we create a new one
            self._data[labelstr] = MetricInstance(
                metric=self,
                labels=labels,
                value=value)

        # we already know this instance
        else:

            # if the value is None, we remove it
            if value is None:
                del self._data[labelstr]
            else:
                # we know this instance, so we update its value
                instance = self._data[labelstr]
                instance.value = value


    def get(self, labels):
        '''Return the last stored value of a metric instance. Returns None if
        the instance does not exist.'''

        labelstr = _get_label_string(labels)

        # If we do not know this instance yet
        if labelstr not in self._data:
            return None

        inst = self._data[labelstr]
        return inst.value


    def inc(self, labels):
        '''Increases the value of the metric instance by one. '''

        val = self.get(labels)

        if val is None:
            val = 0

        val += 1

        self.set(labels, val)


    @property
    def has_timeout(self):
        '''Return true if this metric has an timeout assigned.'''

        return (self.timeout is not None) and (self.timeout > 0)


    def check_timeout(self):
        '''Check all metric instances for timeout and remove the timed out instances.'''

        # find all timed out metric instances
        to_delete = [
            labelstr
            for labelstr, instance in self._data.items()
            if instance.is_timed_out
        ]

        # remove the metric instances
        for labelstr in to_delete:
            del self._data[labelstr]


    def render_iter(self):
        '''Return an iterator returning separate lines in Prometheus format'''

        yield f'# HELP {self.name} {self.helptext}'
        yield f'# TYPE {self.name} {self.datatype}'

        yield from (str(instance) for instance in self._data.values())


    def render(self):
        '''Render the metric to Prometheus format'''

        return '\n'.join(self.render_iter())


    def __str__(self):
        return self._name


class MetricInstance():
    '''Represents a single metric instance. Instances are identified by a unique
    combination of labels and a value.'''

    def __init__(self, metric, labels, value):
        self._metric = metric
        self._labels = labels
        self._label_str = _get_label_string(labels)

        self.value = value


    @property
    def value(self):
        '''Return the value'''

        return self._value


    @value.setter
    def value(self, value):
        '''Set the value'''

        self._value = value
        self._timestamp = _get_time()

        logger.debug(f'Set metric instance {self}')


    @property
    def age(self):
        '''Return the age of the metric value, i.e. when it was last set.'''

        return (_get_time() - self._timestamp).total_seconds()


    @property
    def is_timed_out(self):
        '''Return True if the metric timeout is expired'''

        if not self._metric.has_timeout:
            return False

        return self.age >= self._metric.timeout


    @property
    def label_string(self):
        '''Return the label string of this instance'''
        return self._label_str


    def __str__(self):
        return f'{self._metric.name}{{{self.label_string}}} {self.value}'



class PrometheusExporter():
    '''Manage all measurements and provide the htp interface for interfacing with
    Prometheus.'''

    def __init__(self):
        self._prom = {}
        self._lock = Lock()


    def register(self, name, datatype, helpstr, timeout=None, with_update_counter=False): # pylint: disable=too-many-arguments
        '''Register a name for exporting. This must be called before calling
        `set()`.

        :param str name: The name to register.
        :param str type: One of gauge or counter.
        :param str helpstr: The help information / comment to include in the
          output.
        :param int timeout: Timeout in seconds for any value. Before rendering,
          values which are updated longer ago than this value, are removed.'''

        with self._lock:
            if name in self._prom:
                raise PrometheusExporterException(
                    f"The metric '{name}' is already registered")

            metric = Metric(
                name=name,
                datatype=datatype,
                helpstr=helpstr,
                timeout=timeout,
                with_update_counter=with_update_counter)

            self._prom[name] = metric

        if with_update_counter:
            self.register(
                name=f'{name}_updates',
                datatype='counter',
                helpstr=f'Number of updates to {name}',
                timeout=None)


    def set(self, name, labels, value):
        '''Set a value for exporting.

        :param str name: The name of the value to set. This name must have been
          registered already by calling `register()`.
        :param dict labels: The labels to attach to this name.
        :param value: The value to set. Automatically converted to string.
        :param fmt: The string format to use to convert value to a string.
          Default: '{0}'. '''

        # We raise an exception if we do not know the metric name, i.e. if it
        # was not registered
        if name not in self._prom:
            raise UnknownMeasurementException(
                f"Cannot set not registered measurement '{name}'.")

        with self._lock:
            metric = self._prom[name]

            metric.set(labels, value)

            if metric.with_update_counter:
                counter = self._prom[f'{name}_updates']
                counter.inc(labels)

    def check_timeout(self):
        '''Remove all metric instances which have timed out'''

        with self._lock:
            for metric in self._prom.values():
                metric.check_timeout()

    def render_iter(self):
        '''Return an iterator providing each line of Prometheus output.'''

        for metric in self._prom.values():
            yield from metric.render_iter()


    def render(self):
        '''Render the current data to Prometheus format. See
        https://prometheus.io/docs/instrumenting/exposition_formats/ for details.

        :returns: String with output suitable for consumption by Prometheus over
          HTTP. '''

        self.check_timeout()

        return '\n'.join(self.render_iter())
