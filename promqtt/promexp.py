"""Prometheus exporter"""

import logging
from datetime import datetime
from threading import Lock
from typing import Iterator
from enum import Enum

logger = logging.getLogger(__name__)


class MetricTypeEnum(Enum):
    """Enumeration of metric types"""

    GAUGE = "gauge"
    COUNTER = "counter"

class PrometheusExporterException(Exception):
    """Base class for all exceptions generated by the PrometheusExporter."""


class UnknownMeasurementException(PrometheusExporterException):
    """Raised when you try to set a value for a measurement not registered
    yet."""


def _get_time() -> datetime:
    """Return the current time as a datetime object.

    Wrapped in a function, so it can be stubbed for testing."""

    return datetime.now()


def _get_label_string(labels: dict[str, str]) -> str:
    """Convert a dictionary of labels to a unique label string"""

    labelstr = ",".join([f'{k}="{labels[k]}"' for k in sorted(labels.keys())])

    return labelstr


class Metric:
    """Represents a Prometheus metric, i.e. a metric name with its helptext and type
    information."""

    def __init__( # pylint: disable=too-many-arguments
        self,
        name: str,
        datatype: MetricTypeEnum,
        helpstr: str,
        timeout: int = 0,
        with_update_counter: bool = False,
    ) -> None:
        self._name = name
        self._datatype = datatype
        self._helpstr = helpstr
        self._timeout = timeout
        self._data: dict[str, "MetricInstance"] = {}
        self._with_update_counter = with_update_counter

    @property
    def name(self) -> str:
        """Return the metric name"""
        return self._name

    @property
    def datatype(self) -> MetricTypeEnum:
        """Return the metric datatype (gauge, counter, ...)"""
        return self._datatype

    @property
    def helptext(self) -> str:
        """Return the metric help text"""

        return self._helpstr

    @property
    def timeout(self) -> int:
        """Return the timeout in seconds for this metric. Metric instances are removed
        from the metric after the timeout is expired."""

        return self._timeout

    @property
    def with_update_counter(self) -> bool:
        """Returns true if this metric has an associated update counter metric."""

        return self._with_update_counter

    def set(self, labels: dict[str, str], value: float|None):
        """Set a value for a metric instance"""

        labelstr = _get_label_string(labels)

        # If we do not know this instance yet
        if labelstr not in self._data:
            # we do not add new metrics without assigned value
            if value is None:
                return

            # we don't know this instance yet, so we create a new one
            self._data[labelstr] = MetricInstance(
                metric=self, labels=labels, value=value
            )

        # we already know this instance
        else:
            # if the value is None, we remove it
            if value is None:
                del self._data[labelstr]
            else:
                # we know this instance, so we update its value
                instance = self._data[labelstr]
                instance.value = value

    def get(self, labels: dict[str, str]) -> float | None:
        """Return the last stored value of a metric instance. Returns None if
        the instance does not exist."""

        labelstr = _get_label_string(labels)

        # If we do not know this instance yet
        if labelstr not in self._data:
            return None

        inst = self._data[labelstr]
        return inst.value

    def inc(self, labels: dict[str, str]):
        """Increases the value of the metric instance by one."""

        val = self.get(labels)

        if val is None:
            val = 0

        val += 1

        self.set(labels, val)

    @property
    def has_timeout(self) -> bool:
        """Return true if this metric has an timeout assigned."""

        return (self.timeout is not None) and (self.timeout > 0)

    def check_timeout(self) -> None:
        """Check all metric instances for timeout and remove the timed out instances."""

        # find all timed out metric instances
        to_delete = [
            labelstr
            for labelstr, instance in self._data.items()
            if instance.is_timed_out
        ]

        # remove the metric instances
        for labelstr in to_delete:
            del self._data[labelstr]

    def render_iter(self) -> Iterator[str]:
        """Return an iterator returning separate lines in Prometheus format"""

        yield f"# HELP {self.name} {self.helptext}"
        yield f"# TYPE {self.name} {self.datatype.value}"

        yield from (str(instance) for instance in self._data.values())

    def render(self) -> str:
        """Render the metric to Prometheus format"""

        return "\n".join(self.render_iter())

    def __str__(self) -> str:
        return self._name


class MetricInstance:
    """Represents a single metric instance. Instances are identified by a unique
    combination of labels and a value."""

    def __init__(self, metric: Metric, labels: dict[str, str], value: float):
        self._metric = metric
        self._labels = labels
        self._label_str = _get_label_string(labels)

        self.value = value

    @property
    def value(self) -> float:
        """Return the value"""

        return self._value

    @value.setter
    def value(self, value: float) -> None:
        """Set the value"""

        self._value = value
        self._timestamp = _get_time()

        logger.debug(f"Set metric instance {self}")

    @property
    def age(self) -> float:
        """Return the age of the metric value, i.e. when it was last set."""

        return (_get_time() - self._timestamp).total_seconds()

    @property
    def is_timed_out(self) -> bool:
        """Return True if the metric timeout is expired"""

        if not self._metric.has_timeout:
            return False

        return self.age >= self._metric.timeout

    @property
    def label_string(self) -> str:
        """Return the label string of this instance"""
        return self._label_str

    def __str__(self) -> str:
        return f"{self._metric.name}{{{self.label_string}}} {self.value}"


class PrometheusExporter:
    """Manage all measurements and provide the htp interface for interfacing with
    Prometheus."""

    def __init__(self) -> None:
        self._prom: dict[str, Metric] = {}
        self._lock = Lock()

    def register(
        self,
        name: str,
        datatype: MetricTypeEnum,
        helpstr: str,
        timeout: int = 0,
        with_update_counter: bool = False,
    ):  # pylint: disable=too-many-arguments
        """Register a name for exporting. This must be called before calling
        `set()`.

        :param str name: The name to register.
        :param str type: One of gauge or counter.
        :param str helpstr: The help information / comment to include in the
          output.
        :param int timeout: Timeout in seconds for any value. Before rendering,
          values which are updated longer ago than this value, are removed."""

        with self._lock:
            if name in self._prom:
                raise PrometheusExporterException(
                    f"The metric '{name}' is already registered"
                )

            metric = Metric(
                name=name,
                datatype=datatype,
                helpstr=helpstr,
                timeout=timeout,
                with_update_counter=with_update_counter,
            )

            self._prom[name] = metric

        if with_update_counter:
            self.register(
                name=f"{name}_updates",
                datatype=MetricTypeEnum.COUNTER,
                helpstr=f"Number of updates to {name}",
                timeout=0,
            )

    def set(self, name: str, labels: dict[str, str], value: float|None):
        """Set a value for exporting.

        :param str name: The name of the value to set. This name must have been
          registered already by calling `register()`.
        :param dict labels: The labels to attach to this name.
        :param value: The value to set. Automatically converted to string.
        :param fmt: The string format to use to convert value to a string.
          Default: '{0}'."""

        # We raise an exception if we do not know the metric name, i.e. if it
        # was not registered
        if name not in self._prom:
            raise UnknownMeasurementException(
                f"Cannot set not registered measurement '{name}'."
            )

        with self._lock:
            metric = self._prom[name]

            metric.set(labels, value)

            if metric.with_update_counter:
                counter = self._prom[f"{name}_updates"]
                counter.inc(labels)

    def check_timeout(self) -> None:
        """Remove all metric instances which have timed out"""

        with self._lock:
            for metric in self._prom.values():
                metric.check_timeout()

    def render_iter(self) -> Iterator[str]:
        """Return an iterator providing each line of Prometheus output."""

        for metric in self._prom.values():
            yield from metric.render_iter()

    def render(self) -> str:
        """Render the current data to Prometheus format. See
        https://prometheus.io/docs/instrumenting/exposition_formats/ for details.

        :returns: String with output suitable for consumption by Prometheus over
          HTTP."""

        self.check_timeout()

        return "\n".join(self.render_iter())
